Java中和其他语言不一样，全是有符号的数，可能在用到最大的数然后相加超过了Java
中能表示的最大正整数 --> 负数
**（即二进制数一样，但是有符号和无符号的十进制是不一样的）**

**使用无符号右移 >>>**  相当于除2
左闭右闭
```java
/*  
 * 二分查找  
 */public static int binarySearch(int[] a, int target){  
    //设置左右边界  
    int i = 0,j = a.length - 1;  
  
    //循环查找  
    while (i <= j){  
        int mid = (i + j) >>> 1; //中间元素  
        if (target < a[mid]){  
            j = mid - 1;  
        } else if (a[mid] < target){  
            i = mid + 1;  
        }else {  
            return mid;  
        }  
          
    }  
    return -1;  
}
```

**另一个版本二分**
左闭右开
重点：这里的 J 只是作为边界，指向的一定不是查找目标
	  因此才有了循环时 **j = mid;**  //第三处
	  循环条件中 **i < j** 是因为 j 已经不参与比较了，只做边界

```java
/*  
 * 二分查找改动  
 */public static int binarySearch1(int[] a, int target){  
    //设置左右边界  
    int i = 0,j = a.length; //第一处  
  
    //循环查找  
    while (i < j){     //第二处  
        int mid = (i + j) >>> 1; //中间元素  
  
        if (target < a[mid]){  
            j = mid;  //第三处  
        } else if (a[mid] < target){  
            i = mid + 1;  
        }else {  
            return mid;  
        }  
  
    }  
    return -1;  
}
```

向左找要找L次，向右要找2L次，不平衡，下面给我一个**平衡二分**
缺点，时间复杂度最好最坏都是O(logn)，就在于少了**else if** 那块
```java
public static int binarySearch3(int[] a, int target) {
    int i = 0, j = a.length;
    while (1 < j - i) {
        int m = (i + j) >>> 1;
        if (target < a[m]) {
            j = m;
        } else {
            i = m;
        }
    }
    if (a[i] == target) {
        return i;
    } else {
        return -1;
    }
}
```

最左侧重复元素**Leftmost**
```java
/*  
leftmost最靠做的重复值  
 */public static int binarySearch4(int[] a, int target){  
    //设置左右边界  
    int i = 0,j = a.length - 1;  
    int candidate = -1; //候选值  
  
    //循环查找  
    while (i <= j){  
        int mid = (i + j) >>> 1; //中间元素  
        if (target < a[mid]){  
            j = mid - 1;  
        } else if (a[mid] < target){  
            i = mid + 1;  
        }else {  
            // 记录侯选位置  
            candidate = mid;  
            j = mid - 1;  
        }  
  
    }  
    return candidate;  
}
```

最右侧重复元素**Rightmost**
```java
/*  
rightmost最靠右的重复值  
 */public static int binarySearch5(int[] a, int target){   
    //设置左右边界  
    int i = 0,j = a.length - 1;  
    int candidate = -1;  
    while (i <= j){  
        int mid = (i + j) >>> 1; //中间元素  
        if (target < a[mid]){  
            j = mid - 1;  
        } else if (a[mid] < target){  
            i = mid + 1;  
        }else {  
            // 记录侯选位置  
            candidate = mid;  
            i = mid + 1;  
        }  
    }  
    return candidate;  
}
```

返回值可以改成有用的值
leftmost返回大于等于目标最靠左的位置，rightmost反之亦然

**应用** 
排名
前任-后任
最近邻居
范围查询

1. 求排名 ：leftmost(target) = 结果+1
2. 求前任 ： leftmost(target) - 1 ,求后任反之亦然rightmost(target) + 1
3. 最近邻居 ： 前后任里面找一个更小的就是最近邻居
4. 范围查询 ： 按照实际情况出发


