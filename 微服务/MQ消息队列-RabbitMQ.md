
RabbitMQ的整体架构以及核心概念：
+ VirtualHost：虚拟主机，起到数据隔离的作用（类似于Mysql中的一个个的数据库）
+ publisher：消息发送者
+ consumer：消息的消费者
+ queue：队列，存储消息
+ exchange：交换机，负责路由消息
![](assets/MQ消息队列-RabbitMQ/file-20251128211953142.png)

## Spring AMQP

AMQP是用于应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。

而Spring AMQP 就是基于AMQP定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中**spring-amqp是基础抽象，spring-rabbit是底层的默认实现。** 废话太多，其实这个东西就是让我们收发消息更加简单的

## Work Queues

Work Queues ,**任务模型**，就是让**多个消费者绑定到一个队列，共同消费队列中的消息**
+ 向队列中发消息同一个消息只能被一个消费者能处理
+ 消费者轮询处理消息
+ 当有高并发的时候可以多加几个消费者，解决了消息堆积问题（多个消费者绑定到一个队列，可以加快消息处理速度）
+ 设置preFetch实现能者多劳

默认情况下MQ会将消息轮询投递给绑定在队列上的消费者。处理慢的消费者可能出现**消息堆积**

因此修改 消费者的application.yml，设置preFetch值为1，确保同一时刻最多投递哦给消费者1条消息：
能者多劳
```YAML
spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息
```

这样配置以后处理慢的人就可以先处理完这一条消息才能获取最新消息，避免了消息堆积，实现了能者多劳的局面。

## Fanout交换机

主要作用是**接收**发送者发送的消息，并将消息**路由**到与其绑定的队列。
常见交换机有以下三种：
+ Fanout：广播，会将接收的消息路由到每一个跟其绑定的queue
+ Direct：定向
+ Topic：话题
